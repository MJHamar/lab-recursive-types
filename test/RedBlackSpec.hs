--------------------------------------------------------------------------------
-- Functional Programming (CS141)                                             --
-- Lab: Recursive data types                                                  --
--------------------------------------------------------------------------------

{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module RedBlackSpec (redBlackTreeSpec) where 

--------------------------------------------------------------------------------

import Hedgehog
import qualified Hedgehog.Gen as Gen
import qualified Hedgehog.Range as Range

import Test.Tasty
import Test.Tasty.Hedgehog as H
import Test.Tasty.HUnit 

import Data.List (nub, sort)

import qualified Lab as L

--------------------------------------------------------------------------------

-- | `colour` generates random `Colour` values.
colour :: MonadGen m => m L.Colour 
colour = Gen.element [ L.Red, L.Black ]

-- | `tree` @elementGenerator@ generates random `Tree` values where the elements
-- are generated by @elementGenerator@.
tree :: MonadGen m => m a -> m (L.Tree a)
tree element = Gen.recursive Gen.choice 
    [ pure L.Leaf ]
    [ Gen.subtermM2 (tree element) (tree element) 
        (\l r -> L.Node <$> colour 
                        <*> pure l 
                        <*> element 
                        <*> pure r) 
    ]

--------------------------------------------------------------------------------

prop_singleton :: Property 
prop_singleton = property $ do 
    x <- forAll $ Gen.int Range.constantBounded
    L.singleton x === L.Node L.Red L.empty x L.empty

prop_makeBlack :: Property 
prop_makeBlack = property $ do 
    t <- forAll $ tree (Gen.int Range.constantBounded)
    let r = L.makeBlack t
    annotateShow r
    isValid t r
    where isValid L.Leaf L.Leaf = pure ()
          isValid (L.Node _ l x r) (L.Node L.Black l' x' r') = do 
              annotate "Checking that the left subtree is unchanged"
              l===l'
              annotate "Checking that the element is unchanged"
              x===x'
              annotate "Checking that the right subtree is unchanged"
              r===r'  
          isValid _ _ = failure

prop_depth :: Property 
prop_depth = property $ do 
    t <- forAll $ Gen.filter (/=L.Leaf) $ tree (Gen.int Range.constantBounded)
    diff (L.depth t) (>) 0

prop_member :: Property 
prop_member = property $ do 
    xs <- forAll $ Gen.list (Range.linear 1 100) (Gen.int Range.constantBounded)
    let t = foldl L.insert L.empty xs 
    annotateShow t 
    x <- forAll $ Gen.choice [Gen.element xs, Gen.int Range.constantBounded]
    classify "Element is in the tree" $ elem x xs
    classify "Element is not in the tree" $ not $ elem x xs
    L.member x t === elem x xs

prop_treeDepth :: Property 
prop_treeDepth = property $ do 
    xs <- forAll $ Gen.list (Range.linear 0 100) (Gen.int Range.constantBounded)
    diff (L.depth (foldl L.insert L.empty xs)) 
         (<=) 
         (2*floor (logBase 2 (fromIntegral $ length (nub xs)+1)))

prop_toListSorted :: Property 
prop_toListSorted = property $ do 
    xs <- forAll $ Gen.list (Range.linear 0 100) (Gen.int Range.constantBounded)
    L.toList (foldl L.insert L.empty xs) === sort (nub xs)

--------------------------------------------------------------------------------

-- | The tests for red-black trees.
redBlackTreeSpec :: TestTree
redBlackTreeSpec = testGroup "Red-black trees"
    [ testCase "show Black == \"Black\"" $ show (L.Black) @?= "Black"
    , testCase "show Red == \"Red\"" $ show (L.Red) @?= "Red"
    , testCase "empty represents an empty tree" $ L.empty @?= (L.Leaf :: L.Tree ())
    , H.testProperty "singleton constructs trees with one, red node" prop_singleton
    , H.testProperty "makeBlack makes nodes black" prop_makeBlack
    , testCase "depth Leaf == 0" $ L.depth L.Leaf @?= 0 
    , H.testProperty "depth of a non-empty tree is > 0" $ prop_depth
    , testCase "toList Leaf == []" $ L.toList L.Leaf @?= ([] :: [Int])
    , H.testProperty "member x t == elem x (toList t)" $ prop_member
    , H.testProperty "depth of the tree is at most 2*floor(log2(n+1))" prop_treeDepth
    , H.testProperty "toList returns a sorted list" prop_toListSorted
    ] 

--------------------------------------------------------------------------------
